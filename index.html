<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTrainator - Google Drive Conditioning Helper</title>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <!-- BlueImp Gallery CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/blueimp-gallery/3.4.0/css/blueimp-gallery.min.css">
    <!-- Howler.js for sound -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        .container-fluid {
            max-width: 900px;
            margin: 0 auto;
        }
        #folders {
            margin-top: 20px;
        }
        .folder {
            padding: 10px;
            border: 1px solid #ddd;
            margin-bottom: 8px;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        #status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .hidden {
            display: none;
        }
        #signoutButton {
            margin-left: 10px;
        }
        .loading {
            text-align: center;
            margin: 20px 0;
        }
        pre.debug {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow: auto;
            font-size: 12px;
            max-height: 200px;
        }
        .policy {
            margin-top: 20px;
            margin-bottom: 10px;
        }
        /* BlueImp Gallery customizations */
        .blueimp-gallery > .slides > .slide > .slide-content {
            max-height: 90vh;
            max-width: 90vw;
        }
        .blueimp-gallery > .play-pause {
            position: absolute;
            right: 20px;
            bottom: 20px;
            width: 30px;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
        }
        #login-logout {
            margin: 20px 0;
        }
        #authorize-div {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }
        .image-error {
            color: #721c24;
            background-color: #f8d7da;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .fallback-image {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 4px;
            text-align: center;
        }
        .progress-container {
            margin: 20px 0;
        }
        .progress {
            height: 20px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container-fluid text-center">
        <h1>DTrainator</h1>
        <h4>aka. HTraining Academy Conditioning Helper</h4>
        <p>This tool will help you with your conditioning.</p>
        <ol class="text-left">
            <li>Login with your Google Drive account and select a folder with images.</li>
            <li>Set the beats per minute and after how many beats the next image should appear.</li>
            <li>Press start and fully concentrate on your mantra!</li>
        </ol>
        <p><small><b>Hint:</b> You can use the space bar to pause.</small></p>
        <p><small>You need to be logged in with your Google Account, otherwise the images will not load.</small></p>
        <p class="policy"><a href="privacy.html">Privacy Policy</a> & <a href="https://github.com/sandyslut/conditioning">Source Code</a></p>
        
        <a id="options-toggle" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="advancedOptions" onclick="showOptions();">
            <small><b>Advanced Options</b></small>
        </a>
        <div class="collapse" id="advancedOptions" role="tabpanel">
            <p>You can use the following url parameters to automatically set the options:</p>
            <ul class="text-left">
                <li><b>folder</b> - Folder name that should be selected</li>
                <li><b>shuffle</b> - Set to 1 to activate image shuffling</li>
                <li><b>bpm</b> - Beats per minute</li>
                <li><b>next</b> - After how many beats the next image appears</li>
                <li><b>limit</b> - Limit the number of images</li>
                <li><b>autoplay</b> - After how many seconds the slideshow automatically starts<br><small>On mobile devices there will probably be no sound, because it requires a user interaction.</small></li>
            </ul>
            <p>For example like this: <a href="?bpm=100&next=5&shuffle=1">/?bpm=100&amp;next=5&amp;shuffle=1</a></p>
        </div>
        
        <div class="row">
            <div id="login-logout" class="col-xs-12">
                <div id="authorize-div">
                    <button id="authorize-button" class="btn btn-primary">Sign in with Google</button>
                </div>
                <button id="signout-button" class="btn btn-primary hidden">Sign Out</button>
            </div>
        </div>

        <div class="row">
            <div id="settings" class="hidden col-xs-12 col-sm-6 col-sm-offset-3 col-md-4 col-md-offset-4">
                <form class="form-horizontal" autocomplete="off">
                    <div id="folder-group" class="form-group has-feedback">
                        <label class="control-label col-xs-4" for="folder-select">Folder:</label>
                        <div class="col-xs-8">
                            <select class="form-control" id="folder-select">
                                <option>Select a Google Drive folder...</option>
                            </select>
                            <small id="folder-help" class="form-text text-muted">
                                Select a Google Drive folder...
                            </small>
                            <span class="hidden glyphicon form-control-feedback"></span>
                        </div>
                        <div class="form-check col-xs-8 col-xs-offset-4 text-left">
                            <input id="shuffle-checkbox" type="checkbox" class="form-check-input">
                            <label class="form-check-label" for="shuffle-checkbox">Shuffle images</label>
                        </div>
                    </div>
                    <div id="beats-group" class="form-group has-feedback">
                        <label class="control-label col-xs-4" for="beats-input">BPM:</label>
                        <div class="col-xs-8">
                            <input class="form-control" id="beats-input" type="number">
                            <small id="beats-help" class="form-text text-muted">
                                Set to 0 to just show the gallery.
                            </small>
                            <span class="hidden glyphicon form-control-feedback"></span>
                        </div>
                    </div>
                    <div id="next-group" class="form-group has-feedback">
                        <label class="control-label col-xs-4" for="next-input">Next image:</label>
                        <div class="col-xs-8">
                            <input class="form-control" id="next-input" type="number">
                            <small id="next-help" class="form-text text-muted">
                                Set to 0 to disable the automatic slideshow.
                            </small>
                            <span class="hidden glyphicon form-control-feedback"></span>
                        </div>
                    </div>
                    <div id="limit-group" class="form-group has-feedback">
                        <label class="control-label col-xs-4" for="limit-input">Limit:</label>
                        <div class="col-xs-8">
                            <input class="form-control" id="limit-input" type="number">
                            <small id="limit-help" class="form-text text-muted">
                                Set to 0 to use all files.
                            </small>
                            <span class="hidden glyphicon form-control-feedback"></span>
                        </div>
                    </div>
                </form>
                <button id="start-button" class="btn btn-primary">Start</button>
                <br><br>
                <small id="start-help" class="form-text text-muted"></small>
            </div>
        </div>
        
        <div id="status" class="hidden"></div>
        <div id="loading" class="loading hidden">Loading folders...</div>
        
        <div id="progress-container" class="progress-container hidden">
            <div class="progress">
                <div id="progress-bar" class="progress-bar progress-bar-striped active" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%">
                    <span id="progress-text">0%</span>
                </div>
            </div>
            <div id="progress-status">Preparing images...</div>
        </div>
        
        <div id="debug" class="hidden"></div>
    </div>

    <div id="blueimp-gallery" class="blueimp-gallery blueimp-gallery-controls">
        <div class="slides"></div>
        <a class="prev">‹</a>
        <a class="next">›</a>
        <a class="close">×</a>
        <a id="play-pause" class="play-pause"></a>
        <ol class="indicator"></ol>
    </div>

    <!-- BlueImp Gallery JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-gallery/3.4.0/js/blueimp-gallery.min.js"></script>
    
    <!-- Google API Libraries -->
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    
    <script type="text/javascript">
        // Update the CLIENT_ID and API_KEY with the provided values
        // Client ID and API key from the Developer Console
        var CLIENT_ID = "365428129649-e015ktlfsfksp07i6gv4b64geh12sheb.apps.googleusercontent.com";
        var API_KEY = "AIzaSyC4vG2TsAGSHyXBiaBFG-Ffy_OVcK7hle0";

        // Array of API discovery doc URLs for APIs
        var DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"];

        // Authorization scopes required by the API; multiple scopes can be
        // included, separated by spaces.
        var SCOPES = "https://www.googleapis.com/auth/drive.metadata.readonly https://www.googleapis.com/auth/drive.readonly";

        // Namespace
        var htrainee = {};
        
        // Global variables for authentication
        let gapiInited = false;
        let gisInited = false;
        let tokenClient;

        // Initialize the image cache
        htrainee.imageCache = {};
        
        // Progress elements
        htrainee.progressContainer = document.getElementById("progress-container");
        htrainee.progressBar = document.getElementById("progress-bar");
        htrainee.progressText = document.getElementById("progress-text");
        htrainee.progressStatus = document.getElementById("progress-status");

        function escapeHtml(str) {
            var div = document.createElement("div");
            div.appendChild(document.createTextNode(str));
            return div.innerHTML;
        };

        function parseArgs() {
            var args = [];
            if (window.location.search != "") {
                var tempArray = window.location.search.substring(1).split("&");
                for (var i = 0; i < tempArray.length; i++) {
                    var temp = tempArray[i].split("=");
                    args[escapeHtml(unescape(temp[0]))] = escapeHtml(unescape(temp[1]));
                }
            }
            return args;
        };
        // load args
        htrainee.args = parseArgs();

        // Load some nodes
        htrainee.authorizeButton = document.getElementById("authorize-button");
        htrainee.signoutButton = document.getElementById("signout-button");
        htrainee.settings = document.getElementById("settings");
        htrainee.folderSelect = document.getElementById("folder-select");
        htrainee.shuffleCheckbox = document.getElementById("shuffle-checkbox");
        htrainee.beatsInput = document.getElementById("beats-input");
        htrainee.nextInput = document.getElementById("next-input");
        htrainee.limitInput = document.getElementById("limit-input");
        htrainee.startButton = document.getElementById("start-button");
        htrainee.startHelp = document.getElementById("start-help");
        htrainee.statusDiv = document.getElementById("status");
        htrainee.loadingDiv = document.getElementById("loading");
        htrainee.debugDiv = document.getElementById("debug");
        
        // Create tick sound
        htrainee.tickSound = new Howl({
            src: ["https://assets.codepen.io/21542/tick.mp3"],
            preload: true
        });

        /**
         * Callback after the API client is loaded. Loads the
         * discovery doc to initialize the API.
         */
        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        /**
         * Initializes the API client library and sets up sign-in state
         * listeners.
         */
        async function initializeGapiClient() {
            try {
                await gapi.client.init({
                    apiKey: API_KEY,
                    discoveryDocs: DISCOVERY_DOCS,
                });
                gapiInited = true;
                maybeEnableButtons();
                logDebug('GAPI initialized successfully', {});
            } catch (err) {
                showError('Error initializing GAPI client: ' + (err.message || JSON.stringify(err)));
                logDebug('GAPI Init Error:', err);
            }
        }

        /**
         * Callback after Google Identity Services are loaded.
         */
        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '', // defined later
            });
            gisInited = true;
            maybeEnableButtons();
            logDebug('GIS initialized successfully', {});
        }

        /**
         * Enables user interaction after all libraries are loaded.
         */
        function maybeEnableButtons() {
            if (gapiInited && gisInited) {
                htrainee.authorizeButton.disabled = false;
            }
        }

        /**
         * Sign in the user upon button click.
         */
        function handleAuthClick() {
            showLoading(true);
            
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    showError('Error signing in: ' + resp.error);
                    logDebug('Token Error:', resp);
                    showLoading(false);
                    return;
                }
                
                logDebug('Sign-in successful', {});
                showSuccess("Signed in successfully!");
                updateSigninStatus(true);
                showLoading(false);
            };
            
            if (gapi.client.getToken() === null) {
                // Prompt the user to select a Google Account and ask for consent to share their data
                // when establishing a new session.
                tokenClient.requestAccessToken({prompt: 'consent'});
            } else {
                // Skip display of account chooser and consent dialog for an existing session.
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        /**
         *  Sign out the user upon button click.
         */
        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token, () => {
                    gapi.client.setToken('');
                    updateSigninStatus(false);
                    showSuccess("Signed out successfully");
                    // Clear the image cache when signing out
                    clearImageCache();
                });
            } else {
                updateSigninStatus(false);
            }
        }

        /**
         *  Called when the signed in status changes, to update the UI
         *  appropriately. After a sign-in, the API is called.
         */
        function updateSigninStatus(isSignedIn) {
            if (isSignedIn) {
                htrainee.authorizeButton.classList.add("hidden");
                htrainee.signoutButton.classList.remove("hidden");
                htrainee.settings.classList.remove("hidden");

                // load folders to folder-select
                listFolders();
            } else {
                htrainee.authorizeButton.classList.remove("hidden");
                htrainee.signoutButton.classList.add("hidden");
                htrainee.settings.classList.add("hidden");
            }
        }

        /**
         * List all Google Drive folders in folder-select
         */
        function listFolders() {
            showLoading(true);
            gapi.client.drive.files.list({
                "q": "mimeType contains 'application/vnd.google-apps.folder' and trashed=false",
                "fields": "files(id, name)"
            }).then(function(response) {
                if (!response.error) {
                    var folders = response.result.files;
                    var default_folder;
                    var default_folder_name = "orgasm diet";
                    if (htrainee.args["folder"]) {
                        default_folder_name = htrainee.args["folder"];
                    }

                    if (folders && folders.length > 0) {
                        // Clear existing options
                        htrainee.folderSelect.innerHTML = '';
                        var defaultOption = document.createElement("option");
                        defaultOption.innerHTML = "Select a Google Drive folder...";
                        htrainee.folderSelect.appendChild(defaultOption);
                        
                        for (var i = 0; i < folders.length; i++) {
                            var option = document.createElement("option");
                            option.value = folders[i].id;
                            option.innerHTML = folders[i].name;
                            htrainee.folderSelect.appendChild(option);

                            if (folders[i].name.toLowerCase() == default_folder_name.toLowerCase()) {
                                default_folder = folders[i];
                            }
                        }

                        if (default_folder) {
                            htrainee.folderSelect.value = default_folder.id;
                            listFiles(default_folder.id);
                        }

                        htrainee.folderSelect.onchange = function() {
                            // Clear the image cache when changing folders
                            clearImageCache();
                            listFiles(htrainee.folderSelect.value);
                        }
                        
                        showLoading(false);
                    } else {
                        feedbackError(document.getElementById("folder-group"));
                        document.getElementById("folder-help").innerHTML = "Found no folders.";
                        var option = document.createElement("option");
                        option.innerHTML = "Found no folders";
                        htrainee.folderSelect.appendChild(option);
                        showLoading(false);
                    }
                } else {
                    feedbackError(document.getElementById("folder-group"));
                    document.getElementById("folder-help").innerHTML = "Failed to fetch folders. Error: " + response.error;
                    var option = document.createElement("option");
                    option.innerHTML = "Failed to fetch folders";
                    htrainee.folderSelect.appendChild(option);
                    console.error(response.error);
                    showLoading(false);
                }
            }).catch(function(error) {
                feedbackError(document.getElementById("folder-group"));
                document.getElementById("folder-help").innerHTML = "Failed to fetch folders.";
                logDebug('Folder Error:', error);
                showLoading(false);
            });
        }

        /**
         * Load all files of a google drive folder
         */
        function listFiles(folderId) {
            showLoading(true);
            htrainee.urls = [];
            htrainee.fileIds = [];
            htrainee.fileNames = [];

            // Use a smaller page size to avoid rate limiting
            const pageSize = 20;
            let pageToken = null;
            
            function fetchPage() {
                const params = {
                    'q': "trashed=false and '" + folderId + "' in parents and mimeType contains 'image/' and mimeType != 'application/vnd.google-apps.folder'",
                    'fields': "nextPageToken, files(id, name, mimeType, webContentLink)",
                    'pageSize': pageSize
                };
                
                if (pageToken) {
                    params.pageToken = pageToken;
                }
                
                gapi.client.drive.files.list(params).then(function(response) {
                    if (!response.error) {
                        var files = response.result.files;
                        if (files && files.length > 0) {
                            for (var i = 0; i < files.length; i++) {
                                // Store the file ID and name for later use
                                htrainee.fileIds.push(files[i].id);
                                htrainee.fileNames.push(files[i].name);
                                
                                // Store the file ID for later use with exportFile
                                htrainee.urls.push(files[i].id);
                            }
                            
                            // Check if there are more pages
                            if (response.result.nextPageToken) {
                                pageToken = response.result.nextPageToken;
                                // Wait a short time before fetching the next page to avoid rate limiting
                                setTimeout(fetchPage, 500);
                            } else {
                                // All pages fetched
                                finishListFiles();
                            }
                        } else {
                            // No files in this page
                            finishListFiles();
                        }
                    } else {
                        if (handleRateLimiting(response.error)) {
                            document.getElementById("folder-help").innerHTML = "Rate limit reached. Please try again in a moment.";
                        } else {
                            feedbackError(document.getElementById("folder-group"));
                            document.getElementById("folder-help").innerHTML = "Failed to fetch files. Error: " + response.error;
                            console.error(response.error);
                        }
                        showLoading(false);
                    }
                }).catch(function(error) {
                    if (handleRateLimiting(error)) {
                        document.getElementById("folder-help").innerHTML = "Rate limit reached. Please try again in a moment.";
                    } else {
                        feedbackError(document.getElementById("folder-group"));
                        document.getElementById("folder-help").innerHTML = "Failed to fetch files.";
                        logDebug('Files Error:', error);
                    }
                    showLoading(false);
                });
            }
            
            function finishListFiles() {
                document.getElementById("folder-help").innerHTML = "Loaded " + htrainee.urls.length + " images.";
                
                if (htrainee.urls.length > 0) {
                    feedbackOK(document.getElementById("folder-group"));
                } else {
                    feedbackError(document.getElementById("folder-group"));
                    document.getElementById("folder-help").innerHTML = "No image files in folder.";
                }

                // start autoplay timeout after successful image loading
                var args_autoplay = parseInt(htrainee.args["autoplay"]);
                if (args_autoplay >= 0) {
                    setTimeout(start, args_autoplay * 1000);
                }

                updateStartHelp();
                showLoading(false);
            }
            
            // Start fetching the first page
            fetchPage();
        }

        /**
         * Handle rate limiting errors
         */
        function handleRateLimiting(error) {
            if (error && (error.status === 403 || error.status === 429)) {
                showError("Google Drive rate limit reached. Please wait a moment before trying again.");
                logDebug('Rate limit detected', error);
                return true;
            }
            return false;
        }

        /**
         * Cache an image in memory and in the browser's Cache API
         */
        async function cacheImage(fileId, blob) {
            // In-memory cache
            htrainee.imageCache[fileId] = {
                blob: blob,
                timestamp: Date.now()
            };
            
            // Try to use the Cache API for persistent caching
            try {
                if ('caches' in window) {
                    const cache = await caches.open('htrainee-images');
                    const response = new Response(blob);
                    await cache.put(`image-${fileId}`, response);
                    logDebug('Image cached in Cache API', { fileId });
                }
            } catch (error) {
                logDebug('Failed to cache in Cache API', { fileId, error });
            }
            
            logDebug('Image cached in memory', { fileId });
        }

        /**
         * Get an image from the cache (memory or Cache API)
         */
        async function getImageFromCache(fileId) {
            // First check memory cache
            const cachedImage = htrainee.imageCache[fileId];
            if (cachedImage) {
                // Check if the cache is still valid (1 hour)
                const now = Date.now();
                if (now - cachedImage.timestamp < 3600000) {
                    logDebug('Image retrieved from memory cache', { fileId });
                    return cachedImage.blob;
                } else {
                    // Cache expired, remove it
                    delete htrainee.imageCache[fileId];
                }
            }
            
            // Then check Cache API
            try {
                if ('caches' in window) {
                    const cache = await caches.open('htrainee-images');
                    const response = await cache.match(`image-${fileId}`);
                    if (response) {
                        const blob = await response.blob();
                        // Update memory cache
                        htrainee.imageCache[fileId] = {
                            blob: blob,
                            timestamp: Date.now()
                        };
                        logDebug('Image retrieved from Cache API', { fileId });
                        return blob;
                    }
                }
            } catch (error) {
                logDebug('Failed to retrieve from Cache API', { fileId, error });
            }
            
            return null;
        }

        /**
         * Clear the image cache
         */
        async function clearImageCache() {
            // Clear memory cache
            htrainee.imageCache = {};
            htrainee.cachedGalleryItems = null;
            htrainee.cachedFolderId = null;
            
            // Clear Cache API
            try {
                if ('caches' in window) {
                    await caches.delete('htrainee-images');
                    logDebug('Cache API cleared', {});
                }
            } catch (error) {
                logDebug('Failed to clear Cache API', { error });
            }
            
            logDebug('Image cache cleared', {});
        }

        /**
         * Export a file from Google Drive using a more reliable method
         */
        async function exportFile(fileId) {
            try {
                // Check if the image is in the cache
                const cachedImage = await getImageFromCache(fileId);
                if (cachedImage) {
                    return cachedImage;
                }

                // Get a fresh token if needed
                const token = gapi.client.getToken();
                if (!token) {
                    throw new Error('No authentication token available');
                }

                // Use a direct fetch with the access token instead of gapi.client
                // This can be more reliable for binary data
                const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${token.access_token}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch image: ${response.status}`);
                }

                // Get the blob directly from the response
                const blob = await response.blob();
                
                // Cache the blob
                await cacheImage(fileId, blob);
                
                return blob;
            } catch (error) {
                logDebug('Error exporting file', { fileId, error });
                throw error;
            }
        }

        /**
         * Process images in a queue to avoid rate limiting
         */
        async function processImagesQueue(fileIds, callback) {
            const validItems = [];
            const totalImages = fileIds.length;
            let processedCount = 0;
            let successCount = 0;
            
            if (totalImages === 0) {
                callback([]);
                return;
            }
            
            // Show progress bar
            showProgress(true);
            updateProgress(0, `Preparing images (0/${totalImages})...`);
            
            // Create a queue of images to process
            const queue = [...fileIds];
            
            // Process images one by one with a delay between each
            async function processNext() {
                if (queue.length === 0) {
                    // All images processed
                    updateProgress(100, `Completed! ${successCount}/${totalImages} images loaded successfully`);
                    showProgress(false);
                    callback(validItems);
                    return;
                }
                
                // Get the next file ID from the queue
                const fileId = queue.shift();
                
                try {
                    // Try to export the file
                    const blob = await exportFile(fileId);
                    
                    // Add to valid items
                    validItems.push({
                        fileId: fileId,
                        blob: blob,
                        title: htrainee.fileNames[htrainee.fileIds.indexOf(fileId)] || ''
                    });
                    
                    successCount++;
                    logDebug('Image processed successfully', { fileId });
                } catch (error) {
                    logDebug('Failed to process image', { fileId, error });
                }
                
                // Update progress
                processedCount++;
                const progress = Math.round((processedCount / totalImages) * 100);
                updateProgress(progress, `Preparing images (${processedCount}/${totalImages})...`);
                
                // Process the next image after a delay
                if (queue.length > 0) {
                    // Add a random delay between 300-800ms to avoid detection as automated queries
                    const delay = 300 + Math.floor(Math.random() * 500);
                    setTimeout(processNext, delay);
                } else {
                    // All images processed
                    updateProgress(100, `Completed! ${successCount}/${totalImages} images loaded successfully`);
                    showProgress(false);
                    callback(validItems);
                }
            }
            
            // Start processing the queue
            processNext();
        }

        /**
         * Show or hide the progress bar
         */
        function showProgress(show) {
            if (show) {
                htrainee.progressContainer.classList.remove('hidden');
            } else {
                htrainee.progressContainer.classList.add('hidden');
            }
        }

        /**
         * Update the progress bar
         */
        function updateProgress(percent, status) {
            htrainee.progressBar.style.width = percent + '%';
            htrainee.progressBar.setAttribute('aria-valuenow', percent);
            htrainee.progressText.textContent = percent + '%';
            htrainee.progressStatus.textContent = status;
        }

        /**
         * Custom renderer for BlueImp Gallery to handle blob images
         */
        function customGalleryRenderer(obj, callback) {
    // Create an image element
    const img = document.createElement('img');
    
    // Set crossOrigin to anonymous to avoid CORS issues
    img.crossOrigin = 'anonymous';
    
    // Add debugging for the object
    logDebug('Gallery rendering object', { 
        hasBlob: !!(obj.blob && obj.blob instanceof Blob),
        blobType: obj.blob ? obj.blob.type : 'none',
        blobSize: obj.blob ? obj.blob.size : 0,
        title: obj.title
    });
    
    // Check if we have a valid blob
    if (obj.blob && obj.blob instanceof Blob) {
        try {
            // Create object URL from the blob
            const objectUrl = URL.createObjectURL(obj.blob);
            
            // Set up load handler
            img.onload = function() {
                // Clean up the object URL to avoid memory leaks
                URL.revokeObjectURL(objectUrl);
                callback(img);
            };
            
            // Set up error handler
            img.onerror = function() {
                logDebug('Image failed to load in renderer', { fileId: obj.fileId });
                URL.revokeObjectURL(objectUrl);
                
                // Create a simple fallback image
                img.src = 'data:image/svg+xml;charset=UTF-8,' + 
                    encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="400" height="300" viewBox="0 0 400 300">' +
                    '<rect width="400" height="300" fill="#f0f0f0" />' +
                    '<text x="200" y="150" font-family="Arial" font-size="16" fill="#721c24" text-anchor="middle">Image failed to load</text>' +
                    '<text x="200" y="180" font-family="Arial" font-size="16" fill="#721c24" text-anchor="middle">Please try reloading</text>' +
                    '</svg>');
                
                // Call the callback with the fallback image
                callback(img);
            };
    
            // Set the image source to the object URL
            img.src = objectUrl;
        } catch (error) {
            logDebug('Error creating object URL', { fileId: obj.fileId, error });
            
            // Create a simple fallback image
            img.src = 'data:image/svg+xml;charset=UTF-8,' + 
                encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="400" height="300" viewBox="0 0 400 300">' +
                '<rect width="400" height="300" fill="#f0f0f0" />' +
                '<text x="200" y="150" font-family="Arial" font-size="16" fill="#721c24" text-anchor="middle">Error creating image</text>' +
                '<text x="200" y="180" font-family="Arial" font-size="16" fill="#721c24" text-anchor="middle">Please try again</text>' +
                '</svg>');
            
            // Call the callback with the fallback image
            callback(img);
        }
    } else {
        logDebug('No valid blob for image', { fileId: obj.fileId });
        
        // Create a simple fallback image
        img.src = 'data:image/svg+xml;charset=UTF-8,' + 
            encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="400" height="300" viewBox="0 0 400 300">' +
            '<rect width="400" height="300" fill="#f0f0f0" />' +
            '<text x="200" y="150" font-family="Arial" font-size="16" fill="#721c24" text-anchor="middle">No image data available</text>' +
            '<text x="200" y="180" font-family="Arial" font-size="16" fill="#721c24" text-anchor="middle">Please try reloading</text>' +
            '</svg>');
        
        // Call the callback with the fallback image
        callback(img);
    }
}

// Replace the startGallery function with this updated version
function startGallery(items) {
    var validItems = [...items]; // Clone the array
    
    // If shuffle is checked and we haven't already shuffled (in the case of limiting)
    if (htrainee.shuffleCheckbox.checked && htrainee.limitValue <= 0) {
        shuffle(validItems);
    }

    // Override the default renderer to use our custom one
    blueimp.Gallery.prototype.imageFactory = customGalleryRenderer;

    // Create gallery items in the format expected by BlueImp Gallery
    // Make sure each item has a valid blob
    const galleryItems = validItems.filter(item => item.blob && item.blob instanceof Blob).map(item => ({
        title: item.title || '',
        fileId: item.fileId || '',
        blob: item.blob
    }));

    if (galleryItems.length === 0) {
        showError("No valid images could be loaded. Please try again.");
        showLoading(false);
        return;
    }

    // Add more debugging
    logDebug('Starting gallery with items', { 
        count: galleryItems.length,
        firstItem: galleryItems.length > 0 ? {
            hasBlob: !!(galleryItems[0].blob && galleryItems[0].blob instanceof Blob),
            blobType: galleryItems[0].blob ? galleryItems[0].blob.type : 'none',
            blobSize: galleryItems[0].blob ? galleryItems[0].blob.size : 0,
            title: galleryItems[0].title
        } : 'none'
    });

    // Create the gallery with additional error handling
    try {
        htrainee.gallery = blueimp.Gallery(galleryItems, {
            onclose: stop,
            preloadRange: 2,
            onopened: function() {
                logDebug('Gallery opened', { imageCount: galleryItems.length });
            },
            onerror: function(e) {
                logDebug('Gallery error', e);
            }
        });

        if (htrainee.beats > 0) {
            // Custom event listeners have to be added after gallery ones, so they will be called first
            document.getElementById("play-pause").addEventListener("click", toggleSlideShow);
            document.body.addEventListener("keydown", function(event) {
                var key = event.which || event.keyCode;
                if (key == 32) { // Space
                    toggleSlideShow(event);
                }
            });
        }
        
        if (htrainee.beats > 0) {
            htrainee.startTime = new Date().getTime();
            htrainee.metronome = setTimeout(tick, 1000 / (htrainee.beats / 60));
            document.getElementById("blueimp-gallery").classList.add("blueimp-gallery-playing");
            htrainee.playing = true;
        }
    } catch (error) {
        logDebug('Error creating gallery', error);
        showError("Error creating gallery: " + error.message);
    }
}

// Add a direct method to try viewing a single image for testing
function testViewImage(fileId) {
    if (!fileId && htrainee.fileIds && htrainee.fileIds.length > 0) {
        fileId = htrainee.fileIds[0]; // Use the first image if none specified
    }
    
    if (!fileId) {
        showError("No images available to test");
        return;
    }
    
    showLoading(true);
    logDebug('Testing image view', { fileId });
    
    exportFile(fileId).then(blob => {
        showLoading(false);
        
        if (!blob) {
            showError("Failed to load test image");
            return;
        }
        
        // Create a temporary URL for the blob
        const url = URL.createObjectURL(blob);
        
        // Create a simple viewer
        const viewer = document.createElement('div');
        viewer.style.position = 'fixed';
        viewer.style.top = '0';
        viewer.style.left = '0';
        viewer.style.width = '100%';
        viewer.style.height = '100%';
        viewer.style.backgroundColor = 'rgba(0,0,0,0.8)';
        viewer.style.zIndex = '9999';
        viewer.style.display = 'flex';
        viewer.style.alignItems = 'center';
        viewer.style.justifyContent = 'center';
        
        // Add close button
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.position = 'absolute';
        closeBtn.style.top = '20px';
        closeBtn.style.right = '20px';
        closeBtn.style.zIndex = '10000';
        closeBtn.onclick = function() {
            document.body.removeChild(viewer);
            URL.revokeObjectURL(url);
        };
        
        // Create image
        const img = document.createElement('img');
        img.style.maxWidth = '90%';
        img.style.maxHeight = '90%';
        img.style.objectFit = 'contain';
        img.crossOrigin = 'anonymous';
        
        img.onload = function() {
            logDebug('Test image loaded successfully', { 
                width: img.width, 
                height: img.height,
                naturalWidth: img.naturalWidth,
                naturalHeight: img.naturalHeight
            });
        };
        
        img.onerror = function() {
            logDebug('Test image failed to load', { url });
            img.src = 'data:image/svg+xml;charset=UTF-8,' + 
                encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="400" height="300" viewBox="0 0 400 300">' +
                '<rect width="400" height="300" fill="#f0f0f0" />' +
                '<text x="200" y="150" font-family="Arial" font-size="16" fill="#721c24" text-anchor="middle">Image failed to load</text>' +
                '<text x="200" y="180" font-family="Arial" font-size="16" fill="#721c24" text-anchor="middle">Please try reloading</text>' +
                '</svg>');
        };
        
        img.src = url;
        
        viewer.appendChild(img);
        viewer.appendChild(closeBtn);
        document.body.appendChild(viewer);
    }).catch(error => {
        showLoading(false);
        showError("Error testing image: " + error.message);
        logDebug('Test image error', error);
    });
}

// Add a button to test viewing a single image
window.addEventListener('DOMContentLoaded', function() {
    const testButton = document.createElement('button');
    testButton.textContent = 'Test View First Image';
    testButton.className = 'btn btn-info';
    testButton.style.marginTop = '10px';
    testButton.onclick = function() {
        testViewImage();
    };
    
    // Add it after the start button
    const startButton = document.getElementById('start-button');
    if (startButton && startButton.parentNode) {
        startButton.parentNode.appendChild(testButton);
    }
});
    </script>
</body>
</html>

